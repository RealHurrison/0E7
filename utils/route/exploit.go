package route

import (
	"0E7/utils/config"
	"database/sql"
	"fmt"
	"github.com/gin-gonic/gin"
	"log"
	"os"
	"regexp"
	"strings"
	"time"
)

func exploit(c *gin.Context) {
	client_uuid := c.PostForm("uuid")
	platform := c.PostForm("platform")
	arch := c.PostForm("arch")

	var exploit_uuid, filename, environment, command, argv, timeout string
	var times int
	err := config.Db.QueryRow("SELECT uuid, filename, environment, command, argv, timeout,times FROM `0e7_exploit` WHERE (filter='' OR filter like ?) AND (platform='' OR platform like ?) AND (arch='' OR arch like ?) AND (times<=-2 OR times >=1) ORDER BY RANDOM()", "%"+client_uuid+"%", "%"+platform+"%", "%"+arch+"%").Scan(&exploit_uuid, &filename, &environment, &command, &argv, &timeout, &times)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(202, gin.H{
				"message":      "no task",
				"error":        "",
				"exploit_uuid": "",
				"filename":     "",
				"environment":  "",
				"command":      "",
				"argv":         "",
				"flag":         "",
				"timeout":      "",
			})
			return
		} else {
			log.Println("Failed to query database:", err)
			c.JSON(400, gin.H{
				"message":      "fail",
				"error":        err.Error(),
				"exploit_uuid": "",
				"filename":     "",
				"environment":  "",
				"command":      "",
				"argv":         "",
				"flag":         "",
				"timeout":      "",
			})
			return
		}
	}
	if exploit_uuid == "" {
		c.JSON(202, gin.H{
			"message":      "no task",
			"error":        "",
			"exploit_uuid": "",
			"filename":     "",
			"environment":  "",
			"command":      "",
			"argv":         "",
			"flag":         "",
			"timeout":      "",
		})
	} else {
		if times >= 0 {
			times -= 1
			_, err = config.Db.Exec("UPDATE `0e7_exploit` SET times=? WHERE uuid=?", times, exploit_uuid)
			if err != nil {
				c.JSON(400, gin.H{
					"message":      "fail",
					"error":        err.Error(),
					"exploit_uuid": "",
					"filename":     "",
					"environment":  "",
					"command":      "",
					"argv":         "",
					"flag":         "",
					"timeout":      "",
				})
				c.Abort()
			}
		}
		reg := regexp.MustCompile(`\{[^\}]+\}`)
		matches := reg.FindAllString(argv, -1)

		for _, match := range matches {
			fmt.Println(match)
			action := match[1 : len(match)-2]
			if strings.HasPrefix(action, "ipbucket_") || strings.HasPrefix(action, "cache_") {
				if exploit_bucket[action] == "" {
					var output string
					err = config.Db.QueryRow("SELECT output FROM `0e7_action` WHERE name=? LIMIT 1", action).Scan(&output)
					if err != nil {
						output = ""
					}
					exploit_bucket[action] = output
				}
				if strings.HasPrefix(action, "ipbucket_") && exploit_bucket[action] != "" {
					output := strings.Split(exploit_bucket[action], "\n")
					argv = strings.Replace(argv, match, output[0], 1)
					if len(output) == 1 {
						exploit_bucket[action] = ""
					} else {
						exploit_bucket[action] = strings.Join(output[1:], "\n")
					}
				} else {
					argv = strings.Replace(argv, match, exploit_bucket[action], 1)
				}
			} else {
				var output string
				err = config.Db.QueryRow("SELECT output FROM `0e7_action` WHERE name=? LIMIT 1", action).Scan(&output)
				if err == nil {
					argv = strings.Replace(argv, match, output, 1)
				}
			}
		}

		c.JSON(200, gin.H{
			"message":      "success",
			"error":        "",
			"exploit_uuid": exploit_uuid,
			"filename":     filename,
			"environment":  environment,
			"command":      command,
			"argv":         argv,
			"flag":         config.Server_flag,
			"timeout":      timeout,
		})
	}
}
func exploit_download(c *gin.Context) {
	exploit_uuid := c.PostForm("exploit_uuid")
	filename := c.PostForm("filename")
	filePath := "exploit/" + exploit_uuid + "/" + filename
	_, err := os.Stat(filePath)
	if err != nil {
		c.JSON(404, gin.H{
			"message": "fail",
			"error":   err.Error(),
		})
		c.Abort()
	}
	c.Header("Content-Disposition", "attachment; filename="+filename)
	c.Header("Content-Type", "application/octet-stream")
	c.File(filePath)
}
func exploit_output(c *gin.Context) {
	var err error
	id := c.PostForm("id")
	exploit_uuid := c.PostForm("uuid")
	client_uuid := c.PostForm("client")
	output := c.PostForm("output")
	status := c.PostForm("status")
	updated := time.Now().Format(time.DateTime)
	if id == "" {
		var lastID string
		err := config.Db.QueryRow("INSERT INTO `0e7_exploit_output` (uuid,client,output,status,updated) VALUES (?,?,?,?,?) RETURNING id", exploit_uuid, client_uuid, output, status, updated).Scan(&lastID)
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "success",
			"error":   "",
			"id":      lastID,
		})
	} else {
		if status == "RUNNING" {
			_, err = config.Db.Exec("UPDATE `0e7_exploit_output` SET output=output||?,status=?,updated=? WHERE id=? and status=?", output, status, updated, id, status)
		} else {
			_, err = config.Db.Exec("UPDATE `0e7_exploit_output` SET output=?,status=?,updated=? WHERE id=?", output, status, updated, id)
		}
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "update",
			"error":   "",
			"id":      id,
		})
	}
}
