package route

import (
	"0E7/utils/config"
	"database/sql"
	"fmt"
	"github.com/gin-gonic/gin"
	"math"
	"os"
	"strconv"
	"time"
)

func exploit(c *gin.Context) {
	client_uuid := c.PostForm("uuid")
	platform := c.PostForm("platform")

	var exploit_uuid, filename, environment, command, argv string
	var times int
	err := config.Db.QueryRow("SELECT uuid, filename, environment, command, argv, times FROM `0e7_exploit` WHERE (filter='' OR filter like ?) AND (platform='' OR platform like ?) AND (times<=-2 OR times >=1) ORDER BY RANDOM()", "%"+client_uuid+"%", "%"+platform+"%").Scan(&exploit_uuid, &filename, &environment, &command, &argv, &times)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(204, gin.H{
				"message": "No task",
			})
			return
		} else {
			fmt.Println("Failed to query database:", err)
			c.JSON(400, gin.H{
				"message": err,
			})
			return
		}
	}
	if exploit_uuid == "" {
		c.JSON(204, gin.H{
			"message": "No task",
		})
	} else {
		if times >= 0 {
			times -= 1
			_, err = config.Db.Exec("UPDATE `0e7_exploit` SET times=? WHERE uuid=?", times, exploit_uuid)
			if err != nil {
				c.JSON(400, gin.H{
					"message": err,
				})
				c.Abort()
			}
		}

		c.JSON(200, gin.H{
			"exploit_uuid": exploit_uuid,
			"filename":     filename,
			"environment":  environment,
			"command":      command,
			"argv":         argv,
			"flag":         config.Server_flag,
		})
	}
}
func exploit_download(c *gin.Context) {
	exploit_uuid := c.PostForm("exploit_uuid")
	filename := c.PostForm("filename")
	filePath := "exploit/" + exploit_uuid + "/" + filename
	_, err := os.Stat(filePath)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "File not exist",
		})
		c.Abort()
	}
	c.Header("Content-Disposition", "attachment; filename="+filename)
	c.Header("Content-Type", "application/octet-stream")
	c.File(filePath)
}
func exploit_output(c *gin.Context) {
	var err error
	id := c.PostForm("id")
	exploit_uuid := c.PostForm("uuid")
	client_uuid := c.PostForm("client")
	output := c.PostForm("output")
	status := c.PostForm("status")
	updated := time.Now().Format(time.DateTime)
	if id == "" {
		var lastID string
		err := config.Db.QueryRow("INSERT INTO `0e7_exploit_output` (uuid,client,output,status,updated) VALUES (?,?,?,?,?) RETURNING id", exploit_uuid, client_uuid, output, status, updated).Scan(&lastID)
		if err != nil {
			c.JSON(400, gin.H{
				"message": "insert fail",
				"id":      "",
			})
			fmt.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "insert success",
			"id":      lastID,
		})
	} else {
		if status == "RUNNING" {
			_, err = config.Db.Exec("UPDATE `0e7_exploit_output` SET output=output||?,status=?,updated=? WHERE id=? and status=?", output, status, updated, id, status)
		} else {
			_, err = config.Db.Exec("UPDATE `0e7_exploit_output` SET output=?,status=?,updated=? WHERE id=?", output, status, updated, id)
		}
		if err != nil {
			c.JSON(400, gin.H{
				"message": "update fail",
				"id":      "",
			})
			fmt.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "update success",
			"id":      id,
		})
	}
}

func exploit_show_output(c *gin.Context) {
	var err error
	query_id := c.PostForm("id")
	page_show := c.PostForm("page_show")
	page_num := c.PostForm("page_num")
	var filter_argv []interface{}
	var filter_sql string

	exploit_uuid := c.PostForm("exploit_uuid")
	if exploit_uuid != "" {
		filter_sql = filter_sql + " AND uuid=?"
		filter_argv = append(filter_argv, exploit_uuid)
	}
	client_uuid := c.PostForm("client_uuid")
	if client_uuid != "" {
		filter_sql = filter_sql + " AND client=?"
		filter_argv = append(filter_argv, client_uuid)
	}

	if query_id == "" {
		offset := 1
		if page_num != "" {
			offset, err = strconv.Atoi(page_num)
			if err != nil {
				c.JSON(400, gin.H{
					"messager": err,
				})
				return
			}
			if offset <= 0 {
				offset = 1
			}
		}
		multi := 20
		if page_show != "" {
			multi, err = strconv.Atoi(page_show)
			if err != nil {
				c.JSON(400, gin.H{
					"messager": err,
				})
				return
			}
			if multi <= 0 {
				multi = 1
			}
		}
		var count int
		err := config.Db.QueryRow("SELECT COUNT(*) FROM `0e7_exploit_output` WHERE 1"+filter_sql, filter_argv...).Scan(&count)
		if err != nil {
			c.JSON(400, gin.H{
				"message": err,
			})
			return
		}
		page_count := 1
		if count >= 0 {
			page_count = int(math.Ceil(float64(count) / float64(multi)))
		}
		if page_count < offset {
			if err != nil {
				c.JSON(400, gin.H{
					"message":    "page error",
					"page_show":  multi,
					"page_count": page_count,
				})
				return
			}
		}
		rows, err := config.Db.Query("SELECT id,uuid,client,substr(output, 1, 256),status FROM `0e7_exploit_output` WHERE 1"+filter_sql+" ORDER BY id DESC LIMIT ? OFFSET ?", append(filter_argv, multi, (offset-1)*multi)...)
		if err != nil {
			c.JSON(400, gin.H{
				"message": err.Error(),
			})
			return
		}
		defer rows.Close()

		var ret []map[string]interface{}
		for rows.Next() {
			var id int
			var uuid, client, output, status string
			err := rows.Scan(&id, &uuid, &client, &output, &status)
			if err != nil {
				c.JSON(400, gin.H{
					"message": err.Error(),
				})
				return
			}
			element := map[string]interface{}{
				"id":           id,
				"exploit_uuid": uuid,
				"client_uuid":  client,
				"output":       output,
				"status":       status,
			}
			ret = append(ret, element)
		}

		c.JSON(200, gin.H{
			"message":    "success",
			"page_num":   offset,
			"page_show":  multi,
			"page_count": page_count,
			"result":     ret,
		})
	} else {
		var id int
		var uuid, client, output, status string
		err := config.Db.QueryRow("SELECT id,uuid,client,output,status FROM `0e7_exploit_output` WHERE id=? LIMIT 1", query_id).Scan(&id, &uuid, &client, &output, &status)
		if err != nil {
			c.JSON(400, gin.H{
				"message": err.Error(),
			})
			return
		}
		element := map[string]interface{}{
			"id":           id,
			"exploit_uuid": uuid,
			"client_uuid":  client,
			"output":       output,
			"status":       status,
		}
		c.JSON(200, gin.H{
			"message": "success",
			"result":  element,
		})
	}
}
