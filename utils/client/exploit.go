package client

import (
	"0E7/utils/config"
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"errors"
	"github.com/google/uuid"
	"github.com/traefik/yaegi/interp"
	"github.com/traefik/yaegi/stdlib"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"time"
)

var (
	maxWorkers  = config.Client_worker
	currentJobs = 0
	jobsMutex   sync.Mutex
)

func exploit() {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Exploit error: ", err)
		}
		jobsMutex.Lock()
		currentJobs--
		jobsMutex.Unlock()
	}()
	values := url.Values{}
	values.Set("uuid", config.Client_uuid)
	values.Set("platform", runtime.GOOS)
	values.Set("arch", runtime.GOARCH)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit", requestBody)
	if err != nil {
		log.Println(err)
		return
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
	}
	if response.StatusCode == 200 {
		heartbeat_delay = 5
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}
		exploit_uuid := result["exploit_uuid"].(string)
		filepath := "exploit/" + exploit_uuid + "/"
		filename := result["filename"].(string)
		command := result["command"].(string)
		environment := result["environment"].(string)
		argv := result["argv"].(string)
		flag := result["flag"].(string)

		task_uuid := uuid.New().String()
		exploit_id[task_uuid] = ""
		exploit_output[task_uuid] = ""

		var code, fileType string
		match := regexp.MustCompile(`^data:(code\/(?:python2|python3|golang));base64,(.*)$`).FindStringSubmatch(filename)
		if match != nil {
			_, err := os.Stat(filepath)
			if err != nil {
				err = os.MkdirAll(filepath, os.ModePerm)
				if err != nil {
					log.Println("IO error:", err)
					return
				}
			}
			fileType = match[1]
			data := match[2]
			if fileType == "code/python2" || fileType == "code/python3" {
				filename = exploit_uuid + ".py"
			} else if fileType == "code/golang" {
				filename = exploit_uuid + ".go"
			}
			code_decode, err := base64.StdEncoding.DecodeString(data)
			if err != nil {
				log.Println("Base64 decode error:", err)
				return
			}
			err = ioutil.WriteFile(filepath+"/"+filename, code_decode, 0644)
			if err != nil {
				log.Println("IO error:", err)
				return
			}
			code = string(code_decode)

		} else {
			exploit_download(exploit_uuid, filename)
		}

		lowerStr := strings.ToLower(environment)
		if strings.Contains(lowerStr, "auto_pipreqs") && !set_pipreqs[exploit_uuid] {
			err := auto_pipreqs(filepath)
			if err != nil {
				exploit_output[task_uuid] += err.Error()
			}
		}

		ctx_command, cancel_comand := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel_comand()

		var cmd *exec.Cmd

		var goi *interp.Interpreter
		if command == "" && strings.HasSuffix(filename, ".py") {
			args := []string{"-u", filename}
			args = append(args, splitArgs(argv)...)
			cmd = exec.CommandContext(ctx_command, "python", args...)
		} else if command != "" {
			if runtime.GOOS == "windows" {
				args := []string{"/C", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "cmd.exe", args...)
			} else {
				args := []string{"-c", command}
				args = append(args, splitArgs(argv)...)
				cmd = exec.CommandContext(ctx_command, "/bin/sh", args...)
			}
		} else if fileType != "" {
			cmd = exec.CommandContext(ctx_command, "")
		} else {
			return
		}
		wddir, err := os.Getwd()
		if err != nil {
			log.Println("无法获取当前目录：", err)
			return
		}
		cmd.WaitDelay = time.Duration(15) * time.Second
		cmd.Dir = wddir + "/" + filepath
		envVars := strings.Split(environment, ";")
		cmd.Env = append(os.Environ(), envVars...)
		stdout, err := cmd.StdoutPipe()
		var stdeer bytes.Buffer
		cmd.Stderr = &stdeer
		readout := bufio.NewReader(stdout)
		if err != nil {
			log.Println("Pipe Error:", err)
			return
		}
		status := "RUNNING"

		var goibuf bytes.Buffer
		var wg sync.WaitGroup
		var goierr error
		if fileType == "code/golang" {
			goi = interp.New(interp.Options{Stdout: &goibuf, Stderr: &stdeer, Args: splitArgs(argv), Env: cmd.Env})
			goi.Use(stdlib.Symbols)
			programs[exploit_uuid], err = goi.Compile(code)
			//未清空program，可能导致内存泄漏
			if err != nil {
				log.Println("Compile error:", err.Error())
				return
			}
			readout = bufio.NewReader(&goibuf)
			wg.Add(1)
			go func() {
				defer wg.Done()
				_, goierr = goi.ExecuteWithContext(ctx_command, programs[exploit_uuid])

				if goierr != nil {
					log.Println("Runtime error:", goierr.Error())
					return
				}
			}()
		} else {
			err = cmd.Start()
			if err != nil {
				log.Println(err)
				return
			}
		}
		ctx, cancel := context.WithCancel(context.Background())
		go post_output_scanner(task_uuid, readout)
		var wg_output sync.WaitGroup
		wg_output.Add(1)
		go post_output_status(task_uuid, exploit_uuid, status, ctx, &wg_output)
		if fileType == "" {
			err := cmd.Wait()
			if err != nil {
				log.Println(err)
				status = "ERROR"
				log.Println("RUN " + exploit_uuid + " STDEER:\n" + stdeer.String())
			}
		} else {
			wg.Wait()
			if goierr != nil {
				log.Println(goierr)
				status = "ERROR"
				log.Println("RUN " + exploit_uuid + " STDEER:\n" + stdeer.String())
			}
		}

		if status == "RUNNING" {
			set_pipreqs[exploit_uuid] = true
			status = "SUCCESS"
		}

		cancel()

		if exploit_id[task_uuid] == "" {
			wg_output.Wait()
		}

		post_output_scanner(task_uuid, readout)

		erroutput := stdeer.String()
		if erroutput != "" {
			erroutput = "\nERROR:\n" + erroutput
		}

		exploit_id[task_uuid] = post_output(exploit_id[task_uuid], exploit_uuid, exploit_output[task_uuid]+erroutput, status)

		log.Println("RUN " + exploit_uuid + " OUTPUT:\n" + exploit_output[task_uuid])

		if flag != "" {
			regexpObj := regexp.MustCompile(flag)
			matches := regexpObj.FindAllString(exploit_output[task_uuid], -1)
			for _, match := range matches {
				post_flag(exploit_uuid, match)
			}
		}

		programs[task_uuid] = nil
		exploit_id[task_uuid] = ""
		exploit_output[task_uuid] = ""

	} else {
		heartbeat_delay += 5
		if heartbeat_delay >= 60 {
			heartbeat_delay = 60
		}
	}

}

func splitArgs(input string) []string {
	var args []string
	start := -1
	inQuote := false

	for i, char := range input {
		if char == '"' {
			inQuote = !inQuote
		} else if char == ' ' && !inQuote {
			if start >= 0 {
				if input[start] == '"' && input[i-1] == '"' {
					args = append(args, input[start+1:i-1])
				} else {
					args = append(args, input[start:i])
				}
				start = -1
			}
			continue
		}

		if start < 0 {
			start = i
		}
	}

	if start >= 0 {
		if input[start] == '"' && input[len(input)-1] == '"' {
			args = append(args, input[start+1:len(input)-1])
		} else {
			args = append(args, input[start:])
		}
	}

	return args
}

func post_output_scanner(task_uuid string, readout *bufio.Reader) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output scanner Error:", err)
		}
	}()
	outputBytes := make([]byte, 200)
	for {
		n, err := readout.Read(outputBytes)
		if err != nil {
			if errors.Is(err, io.EOF) || errors.Is(err, fs.ErrClosed) {
				return
			}
			log.Println(err)
			exploit_output[task_uuid] += err.Error()
			return
		}
		output := string(outputBytes[:n])
		//log.Print(output)
		exploit_output[task_uuid] += output
	}
}
func post_output_status(task_uuid string, exploit_uuid string, status string, ctx context.Context, wg_output *sync.WaitGroup) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Post output Status Error:", err)
		}
	}()
	run := false
	old_len := 0
	for {
		select {
		case <-ctx.Done():
			wg_output.Done()
			return
		}
		new_len := len(exploit_output[task_uuid])
		exploit_id[task_uuid] = post_output(exploit_id[task_uuid], exploit_uuid, exploit_output[task_uuid][old_len:new_len], status)
		old_len = new_len
		if run == false {
			run = true
			wg_output.Done()
		}
		time.Sleep(5 * time.Second)
	}
}
func post_output(id string, exploit_uuid string, output string, status string) string {
	values := url.Values{}
	values.Set("id", id)
	values.Set("uuid", exploit_uuid)
	values.Set("client", config.Client_uuid)
	values.Set("output", output)
	values.Set("status", status)

	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_output", requestBody)
	if err != nil {
		log.Println(err)
		return ""
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
		return ""
	}
	if response.StatusCode == 200 {
		//log.Printf("Post success")
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			log.Println(err)
		}
		return result["id"].(string)
	} else {
		log.Printf("Postfail with %d", response.StatusCode)
		return ""
	}
}

func post_flag(exploit_uuid string, exploit_flag string) {
	values := url.Values{}
	values.Set("uuid", exploit_uuid)
	values.Set("flag", exploit_flag)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/flag", requestBody)
	if err != nil {
		log.Println(err)
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		log.Println(err)
	}
	if response.StatusCode == 200 {
		log.Printf("Post %s success", exploit_flag)
	} else if response.StatusCode == 202 {
		log.Printf("Post %s skipped", exploit_flag)
	} else {
		log.Printf("Post %s fail with %d", exploit_flag, response.StatusCode)
	}
}

func auto_pipreqs(filepath string) error {

	cmd := exec.Command("pip", "install", "pipreqs", "-i", config.Client_pypi)
	err := cmd.Start()
	if err != nil {
		log.Println("AUTO PIPREQS:", err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("AUTO PIPREQS:", err.Error())
		return err
	}

	cmd = exec.Command("pipreqs", "--encoding=utf-8", filepath, "--savepath", filepath+"auto_pipreqs.txt", "--force", "--mode", "no-pin")

	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("AUTO PIPREQS:", err.Error())
		return err
	}

	cmd = exec.Command("pip", "install", "-r", filepath+"auto_pipreqs.txt", "-i", config.Client_pypi)
	err = cmd.Start()
	if err != nil {
		log.Println(err.Error())
		return err
	}
	if err = cmd.Wait(); err != nil {
		log.Println("AUTO PIPREGS:", err.Error())
		return err
	}
	return nil
}

/*
	func setenv(environment string) {
		vars := strings.Split(environment, ";")
		for _, v := range vars {
			kv := strings.SplitN(v, "=", 2)
			if len(kv) == 2 {
				key := kv[0]
				value := kv[1]
				os.Setenv(key, value)
			}
		}
	}
*/
func exploit_download(exploit_uuid string, filename string) error {
	if filename == "" {
		return nil
	}
	values := url.Values{}
	values.Set("exploit_uuid", exploit_uuid)
	values.Set("filename", filename)
	filepath := "exploit/" + exploit_uuid
	_, err := os.Stat(filepath)
	if err == nil {
		return nil
	}
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_download", requestBody)
	if err != nil {
		return err
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_download) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		return err
	}
	defer response.Body.Close()
	err = os.MkdirAll(filepath, os.ModePerm)
	if err != nil {
		return err
	}
	out, err := os.Create(filepath + "/" + filename)
	if err != nil {
		return err
	}
	defer out.Close()
	_, err = io.Copy(out, response.Body)
	if err != nil {
		return err
	}
	if strings.HasSuffix(filename, ".zip") {
		Unzip(filename, exploit_uuid)
	} else if strings.HasSuffix(filename, ".tar") {
		Untar(filename, exploit_uuid)
	}
	return nil
}
func Unzip(zipFile string, exploit_uuid string) error {
	destDir := "exploit/" + exploit_uuid + "/"
	zipFile = destDir + zipFile
	r, err := zip.OpenReader(zipFile)
	if err != nil {
		log.Println(err)
		return err
	}
	defer r.Close()
	for _, file := range r.File {
		rc, err := file.Open()
		if err != nil {
			log.Println(err)
			return err
		}
		defer rc.Close()
		path := filepath.Join(destDir, file.Name)
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
			if err != nil {
				log.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, rc)
			if err != nil {
				log.Println(err)
				return err
			}
		}
	}
	log.Println("解压zip完成")
	return nil
}
func Untar(tarFile string, exploit_uuid string) error {
	destDir := "exploit/" + exploit_uuid + "/"
	tarFile = destDir + tarFile
	f, err := os.Open(tarFile)
	if err != nil {
		log.Println(err)
		return err
	}
	defer f.Close()
	err = os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		log.Println(err)
		return err
	}
	tr := tar.NewReader(f)
	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Println(err)
			return err
		}
		path := filepath.Join(destDir, header.Name)
		if header.Typeflag == tar.TypeDir {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.FileInfo().Mode())
			if err != nil {
				log.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, tr)
			if err != nil {
				log.Println(err)
				return err
			}
		}
	}
	log.Println("解压tar完成")
	return nil
}
