package route

import (
	"0E7/service/config"
	"0E7/service/database"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

func exploit(c *gin.Context) {
	client_id_str := c.PostForm("client_id")
	platform := c.PostForm("platform")
	arch := c.PostForm("arch")

	var exploit database.Exploit
	err := config.Db.Where("(filter = '' OR filter LIKE ?) AND (platform = '' OR platform LIKE ?) AND (arch = '' OR arch LIKE ?) AND (times <= -2 OR times >= 1)",
		"%"+client_id_str+"%", "%"+platform+"%", "%"+arch+"%").
		Order("RANDOM()").
		First(&exploit).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(202, gin.H{
				"message":     "no task",
				"error":       "",
				"name":        "",
				"filename":    "",
				"environment": "",
				"command":     "",
				"argv":        "",
				"flag":        "",
				"timeout":     "",
			})
			return
		} else {
			log.Println("Failed to query database:", err)
			c.JSON(400, gin.H{
				"message":     "fail",
				"error":       err.Error(),
				"name":        "",
				"filename":    "",
				"environment": "",
				"command":     "",
				"argv":        "",
				"flag":        "",
				"timeout":     "",
			})
			return
		}
	}
	if exploit.Name == "" {
		c.JSON(202, gin.H{
			"message":     "no task",
			"error":       "",
			"name":        "",
			"filename":    "",
			"environment": "",
			"command":     "",
			"argv":        "",
			"flag":        "",
			"timeout":     "",
		})
	} else {
		times, _ := strconv.Atoi(exploit.Times)
		if times >= 0 {
			times -= 1
			err = config.Db.Model(&exploit).Where("id = ?", exploit.ID).Update("times", fmt.Sprintf("%d", times)).Error
			if err != nil {
				c.JSON(400, gin.H{
					"message":     "fail",
					"error":       err.Error(),
					"name":        "",
					"filename":    "",
					"environment": "",
					"command":     "",
					"argv":        "",
					"flag":        "",
					"timeout":     "",
				})
				c.Abort()
			}
		}
		reg := regexp.MustCompile(`\{[^\}]+\}`)
		matches := reg.FindAllString(exploit.Argv, -1)

		for _, match := range matches {
			fmt.Println(match)
			action := match[1 : len(match)-2]
			if strings.HasPrefix(action, "ipbucket_") || strings.HasPrefix(action, "cache_") {
				if exploit_bucket[action] == "" {
					var actionRecord database.Action
					err = config.Db.Where("name = ?", action).First(&actionRecord).Error
					if err != nil {
						actionRecord.Output = ""
					}
					exploit_bucket[action] = actionRecord.Output
				}
				if strings.HasPrefix(action, "ipbucket_") && exploit_bucket[action] != "" {
					output := strings.Split(exploit_bucket[action], "\n")
					exploit.Argv = strings.Replace(exploit.Argv, match, output[0], 1)
					if len(output) == 1 {
						exploit_bucket[action] = ""
					} else {
						exploit_bucket[action] = strings.Join(output[1:], "\n")
					}
				} else {
					exploit.Argv = strings.Replace(exploit.Argv, match, exploit_bucket[action], 1)
				}
			} else {
				var actionRecord database.Action
				err = config.Db.Where("name = ?", action).First(&actionRecord).Error
				if err == nil {
					exploit.Argv = strings.Replace(exploit.Argv, match, actionRecord.Output, 1)
				}
			}
		}
		if exploit.Flag == "" {
			exploit.Flag = config.Server_flag
		}
		c.JSON(200, gin.H{
			"message":     "success",
			"error":       "",
			"id":          exploit.ID,
			"name":        exploit.Name,
			"filename":    exploit.Filename,
			"environment": exploit.Environment,
			"command":     exploit.Command,
			"argv":        exploit.Argv,
			"flag":        config.Server_flag,
			"flag_regex":  exploit.Flag,
			"timeout":     exploit.Timeout,
		})
	}
}
func exploit_download(c *gin.Context) {
	exploit_id := c.PostForm("id")
	filename := c.PostForm("filename")
	filePath := "upload/" + exploit_id + "/" + filename
	_, err := os.Stat(filePath)
	if err != nil {
		c.JSON(404, gin.H{
			"message": "fail",
			"error":   err.Error(),
		})
		c.Abort()
	}
	c.Header("Content-Disposition", "attachment; filename="+filename)
	c.Header("Content-Type", "application/octet-stream")
	c.File(filePath)
}
func exploit_output(c *gin.Context) {
	var err error
	id := c.PostForm("id")
	exploit_id_str := c.PostForm("exploit_id")
	client_id_str := c.PostForm("client_id")
	output := c.PostForm("output")
	status := c.PostForm("status")

	// 转换exploit_id为int
	exploit_id, err := strconv.Atoi(exploit_id_str)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "fail",
			"error":   "invalid exploit_id: " + err.Error(),
			"id":      "",
		})
		log.Println("Invalid exploit_id:", err)
		return
	}

	// 转换client_id为int
	client_id, err := strconv.Atoi(client_id_str)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "fail",
			"error":   "invalid client_id: " + err.Error(),
			"id":      "",
		})
		log.Println("Invalid client_id:", err)
		return
	}

	if id == "" {
		exploitOutput := database.ExploitOutput{
			ExploitId: exploit_id,
			ClientId:  client_id,
			Output:    output,
			Status:    status,
		}
		err := config.Db.Create(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "success",
			"error":   "",
			"id":      fmt.Sprintf("%d", exploitOutput.ID),
		})
	} else {
		var exploitOutput database.ExploitOutput
		err = config.Db.First(&exploitOutput, id).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}

		if status == "RUNNING" {
			exploitOutput.Output += output
		} else {
			exploitOutput.Output = output
		}
		exploitOutput.Status = status

		err = config.Db.Save(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "update",
			"error":   "",
			"id":      id,
		})
	}
}
