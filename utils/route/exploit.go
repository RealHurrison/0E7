package route

import (
	"0E7/utils/config"
	"0E7/utils/database"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

func exploit(c *gin.Context) {
	client_uuid := c.PostForm("uuid")
	platform := c.PostForm("platform")
	arch := c.PostForm("arch")

	var exploit database.Exploit
	err := config.Db.Where("(filter = '' OR filter LIKE ?) AND (platform = '' OR platform LIKE ?) AND (arch = '' OR arch LIKE ?) AND (times <= -2 OR times >= 1)",
		"%"+client_uuid+"%", "%"+platform+"%", "%"+arch+"%").
		Order("RANDOM()").
		First(&exploit).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(202, gin.H{
				"message":      "no task",
				"error":        "",
				"exploit_uuid": "",
				"filename":     "",
				"environment":  "",
				"command":      "",
				"argv":         "",
				"flag":         "",
				"timeout":      "",
			})
			return
		} else {
			log.Println("Failed to query database:", err)
			c.JSON(400, gin.H{
				"message":      "fail",
				"error":        err.Error(),
				"exploit_uuid": "",
				"filename":     "",
				"environment":  "",
				"command":      "",
				"argv":         "",
				"flag":         "",
				"timeout":      "",
			})
			return
		}
	}
	if exploit.UUID == "" {
		c.JSON(202, gin.H{
			"message":      "no task",
			"error":        "",
			"exploit_uuid": "",
			"filename":     "",
			"environment":  "",
			"command":      "",
			"argv":         "",
			"flag":         "",
			"timeout":      "",
		})
	} else {
		times, _ := strconv.Atoi(exploit.Times)
		if times >= 0 {
			times -= 1
			err = config.Db.Model(&exploit).Where("uuid = ?", exploit.UUID).Update("times", fmt.Sprintf("%d", times)).Error
			if err != nil {
				c.JSON(400, gin.H{
					"message":      "fail",
					"error":        err.Error(),
					"exploit_uuid": "",
					"filename":     "",
					"environment":  "",
					"command":      "",
					"argv":         "",
					"flag":         "",
					"timeout":      "",
				})
				c.Abort()
			}
		}
		reg := regexp.MustCompile(`\{[^\}]+\}`)
		matches := reg.FindAllString(exploit.Argv, -1)

		for _, match := range matches {
			fmt.Println(match)
			action := match[1 : len(match)-2]
			if strings.HasPrefix(action, "ipbucket_") || strings.HasPrefix(action, "cache_") {
				if exploit_bucket[action] == "" {
					var actionRecord database.Action
					err = config.Db.Where("name = ?", action).First(&actionRecord).Error
					if err != nil {
						actionRecord.Output = ""
					}
					exploit_bucket[action] = actionRecord.Output
				}
				if strings.HasPrefix(action, "ipbucket_") && exploit_bucket[action] != "" {
					output := strings.Split(exploit_bucket[action], "\n")
					exploit.Argv = strings.Replace(exploit.Argv, match, output[0], 1)
					if len(output) == 1 {
						exploit_bucket[action] = ""
					} else {
						exploit_bucket[action] = strings.Join(output[1:], "\n")
					}
				} else {
					exploit.Argv = strings.Replace(exploit.Argv, match, exploit_bucket[action], 1)
				}
			} else {
				var actionRecord database.Action
				err = config.Db.Where("name = ?", action).First(&actionRecord).Error
				if err == nil {
					exploit.Argv = strings.Replace(exploit.Argv, match, actionRecord.Output, 1)
				}
			}
		}

		c.JSON(200, gin.H{
			"message":      "success",
			"error":        "",
			"exploit_uuid": exploit.UUID,
			"filename":     exploit.Filename,
			"environment":  exploit.Environment,
			"command":      exploit.Command,
			"argv":         exploit.Argv,
			"flag":         config.Server_flag,
			"timeout":      exploit.Timeout,
		})
	}
}
func exploit_download(c *gin.Context) {
	exploit_uuid := c.PostForm("exploit_uuid")
	filename := c.PostForm("filename")
	filePath := "exploit/" + exploit_uuid + "/" + filename
	_, err := os.Stat(filePath)
	if err != nil {
		c.JSON(404, gin.H{
			"message": "fail",
			"error":   err.Error(),
		})
		c.Abort()
	}
	c.Header("Content-Disposition", "attachment; filename="+filename)
	c.Header("Content-Type", "application/octet-stream")
	c.File(filePath)
}
func exploit_output(c *gin.Context) {
	var err error
	id := c.PostForm("id")
	exploit_uuid := c.PostForm("uuid")
	client_uuid := c.PostForm("client")
	output := c.PostForm("output")
	status := c.PostForm("status")

	if id == "" {
		exploitOutput := database.ExploitOutput{
			UUID:   exploit_uuid,
			Client: client_uuid,
			Output: output,
			Status: status,
		}
		err := config.Db.Create(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "success",
			"error":   "",
			"id":      fmt.Sprintf("%d", exploitOutput.ID),
		})
	} else {
		var exploitOutput database.ExploitOutput
		err = config.Db.First(&exploitOutput, id).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}

		if status == "RUNNING" {
			exploitOutput.Output += output
		} else {
			exploitOutput.Output = output
		}
		exploitOutput.Status = status

		err = config.Db.Save(&exploitOutput).Error
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail",
				"error":   err.Error(),
				"id":      "",
			})
			log.Println(err)
			return
		}
		c.JSON(200, gin.H{
			"message": "update",
			"error":   "",
			"id":      id,
		})
	}
}
