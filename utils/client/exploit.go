package client

import (
	"0E7/utils/config"
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"io"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"time"
)

var (
	maxWorkers  = config.Client_worker
	currentJobs = 0
	jobsMutex   sync.Mutex
)

func exploit() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("Exploit Error:", err)
		}
		jobsMutex.Lock()
		currentJobs--
		jobsMutex.Unlock()
	}()
	values := url.Values{}
	values.Set("uuid", config.Client_uuid)
	values.Set("platform", runtime.GOOS)
	values.Set("arch", runtime.GOARCH)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit", requestBody)
	if err != nil {
		fmt.Println(err)
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println(err)
	}
	if response.StatusCode == 200 {
		heartbeat_delay = 5
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			fmt.Println(err)
		}
		exploit_uuid := result["exploit_uuid"].(string)
		filepath := "exploit/" + exploit_uuid + "/"
		filename := result["filename"].(string)
		command := result["command"].(string)
		environment := result["environment"].(string)
		argv := result["argv"].(string)
		flag := result["flag"].(string)
		exploit_download(exploit_uuid, filename)

		lowerStr := strings.ToLower(environment)
		if strings.Contains(lowerStr, "auto_pipreqs") && !set_pipreqs[exploit_uuid] {
			auto_pipreqs(filepath)
		}
		var cmd *exec.Cmd
		if command == "" && strings.HasSuffix(filename, ".py") {
			cmd = exec.Command("python", "-u", filename, argv)
			//cmd = exec.Command("ping", "baidu.com", "-n", "100")
		} else if command != "" {
			cmd = exec.Command("cmd.exe", "/C", command, argv)
		} else {
			return
		}
		wddir, err := os.Getwd()
		if err != nil {
			fmt.Println("无法获取当前目录：", err)
			return
		}
		cmd.Dir = wddir + "/" + filepath
		envVars := strings.Split(environment, ";")
		cmd.Env = append(os.Environ(), envVars...)
		stdout, err := cmd.StdoutPipe()
		var stdeer bytes.Buffer
		cmd.Stderr = &stdeer
		readout := bufio.NewReader(stdout)
		if err != nil {
			fmt.Println("Pipe Error:", err)
			return
		}
		status := "RUNNING"
		err = cmd.Start()
		if err != nil {
			fmt.Println(err)
			return
		}

		task_uuid := uuid.New().String()
		exploit_id[task_uuid] = ""
		exploit_output[task_uuid] = ""
		ctx, cancel := context.WithCancel(context.Background())
		go post_output_scanner(task_uuid, readout, ctx)
		go post_output_status(task_uuid, exploit_uuid, status, ctx)
		err = cmd.Wait()
		if err != nil {
			fmt.Println(err)
			status = "ERROR"
			fmt.Println("RUN " + exploit_uuid + " STDEER:\n" + stdeer.String())
		} else {
			set_pipreqs[exploit_uuid] = true
			status = "SUCCESS"
		}

		cancel()

		if exploit_id[task_uuid] == "" {
			<-ctx.Done()
		}
		erroutput := stdeer.String()
		if erroutput != "" {
			erroutput = "\nERROR:\n" + erroutput
		}
		exploit_id[task_uuid] = post_output(exploit_id[task_uuid], exploit_uuid, exploit_output[task_uuid]+erroutput, status)

		fmt.Println("RUN " + exploit_uuid + " OUTPUT:\n" + exploit_output[task_uuid])

		if flag != "" {
			regexpObj := regexp.MustCompile(flag)
			matches := regexpObj.FindAllString(exploit_output[task_uuid], -1)
			for _, match := range matches {
				post_flag(exploit_uuid, match)
			}
		}

		exploit_id[task_uuid] = ""
		exploit_output[task_uuid] = ""

	} else {
		heartbeat_delay += 5
		if heartbeat_delay >= 60 {
			heartbeat_delay = 60
		}
	}

}
func post_output_scanner(task_uuid string, readout *bufio.Reader, ctx context.Context) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("Post output scanner Error:", err)
		}
	}()
	outputBytes := make([]byte, 200)
	for {
		n, err := readout.Read(outputBytes)
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Println(err)
			exploit_output[task_uuid] += err.Error()
		}
		output := string(outputBytes[:n])
		//fmt.Print(output)
		exploit_output[task_uuid] += output
	}
}
func post_output_status(task_uuid string, exploit_uuid string, status string, ctx context.Context) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("Post output Status Error:", err)
		}
	}()
	old_len := 0
	for {
		select {
		case <-ctx.Done():
			return
		default:
			{
				new_len := len(exploit_output[task_uuid])
				exploit_id[task_uuid] = post_output(exploit_id[task_uuid], exploit_uuid, exploit_output[task_uuid][old_len:new_len], status)
				//fmt.Println(old_len, new_len, exploit_output[task_uuid])
				old_len = new_len
				time.Sleep(5 * time.Second)
			}
		}
	}
}
func post_output(id string, exploit_uuid string, output string, status string) string {
	values := url.Values{}
	values.Set("id", id)
	values.Set("uuid", exploit_uuid)
	values.Set("client", config.Client_uuid)
	values.Set("output", output)
	values.Set("status", status)

	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_output", requestBody)
	if err != nil {
		fmt.Println(err)
		return ""
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println(err)
		return ""
	}
	if response.StatusCode == 200 {
		//fmt.Printf("Post success")
		var result map[string]interface{}
		err = json.NewDecoder(response.Body).Decode(&result)
		if err != nil {
			fmt.Println(err)
		}
		return result["id"].(string)
	} else {
		fmt.Printf("Postfail with %d", response.StatusCode)
		return ""
	}
}

func post_flag(exploit_uuid string, exploit_flag string) {
	values := url.Values{}
	values.Set("uuid", exploit_uuid)
	values.Set("flag", exploit_flag)
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/flag", requestBody)
	if err != nil {
		fmt.Println(err)
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_http) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		fmt.Println(err)
	}
	if response.StatusCode == 200 {
		fmt.Printf("Post %s success", exploit_flag)
	} else if response.StatusCode == 204 {
		fmt.Printf("Post %s skipped", exploit_flag)
	} else {
		fmt.Printf("Post %s fail with %d", exploit_flag, response.StatusCode)
	}
}

func auto_pipreqs(filepath string) {

	cmd := exec.Command("pip", "install", "pipreqs", "-i", config.Client_pypi)
	err := cmd.Start()
	if err != nil {
		fmt.Println("AUTO PIPREQS:", err)
		return
	}
	if err = cmd.Wait(); err != nil {
		fmt.Println("AUTO PIPREQS:", err)
		return
	}

	cmd = exec.Command("pipreqs", "--encoding=utf-8", filepath, "--savepath", filepath+"auto_pipreqs.txt", "--force", "--mode", "no-pin")

	err = cmd.Start()
	if err != nil {
		fmt.Println(err)
		return
	}
	if err = cmd.Wait(); err != nil {
		fmt.Println("AUTO PIPREQS:", err)
		return
	}

	cmd = exec.Command("pip", "install", "-r", filepath+"auto_pipreqs.txt", "-i", config.Client_pypi)
	err = cmd.Start()
	if err != nil {
		fmt.Println(err)
		return
	}
	if err = cmd.Wait(); err != nil {
		fmt.Println("AUTO PIPREGS:", err)
		return
	}
}

/*
	func setenv(environment string) {
		vars := strings.Split(environment, ";")
		for _, v := range vars {
			kv := strings.SplitN(v, "=", 2)
			if len(kv) == 2 {
				key := kv[0]
				value := kv[1]
				os.Setenv(key, value)
			}
		}
	}
*/
func exploit_download(exploit_uuid string, filename string) error {
	values := url.Values{}
	values.Set("exploit_uuid", exploit_uuid)
	values.Set("filename", filename)
	filepath := "exploit/" + exploit_uuid
	_, err := os.Stat(filepath)
	if err == nil {
		return nil
	}
	requestBody := bytes.NewBufferString(values.Encode())
	request, err := http.NewRequest("POST", config.Server_url+"/api/exploit_download", requestBody)
	if err != nil {
		return err
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	client := &http.Client{Timeout: time.Duration(config.Global_timeout_download) * time.Second,
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
	response, err := client.Do(request)
	if err != nil {
		return err
	}
	defer response.Body.Close()
	err = os.MkdirAll(filepath, os.ModePerm)
	if err != nil {
		return err
	}
	out, err := os.Create(filepath + "/" + filename)
	if err != nil {
		return err
	}
	defer out.Close()
	_, err = io.Copy(out, response.Body)
	if err != nil {
		return err
	}
	if strings.HasSuffix(filename, ".zip") {
		Unzip(filename, exploit_uuid)
	} else if strings.HasSuffix(filename, ".tar") {
		Untar(filename, exploit_uuid)
	}
	return nil
}
func Unzip(zipFile string, exploit_uuid string) error {
	destDir := "exploit/" + exploit_uuid + "/"
	zipFile = destDir + zipFile
	r, err := zip.OpenReader(zipFile)
	if err != nil {
		fmt.Println(err)
		return err
	}
	defer r.Close()
	for _, file := range r.File {
		rc, err := file.Open()
		if err != nil {
			fmt.Println(err)
			return err
		}
		defer rc.Close()
		path := filepath.Join(destDir, file.Name)
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
			if err != nil {
				fmt.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, rc)
			if err != nil {
				fmt.Println(err)
				return err
			}
		}
	}
	fmt.Println("解压zip完成")
	return nil
}
func Untar(tarFile string, exploit_uuid string) error {
	destDir := "exploit/" + exploit_uuid + "/"
	tarFile = destDir + tarFile
	f, err := os.Open(tarFile)
	if err != nil {
		fmt.Println(err)
		return err
	}
	defer f.Close()
	err = os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return err
	}
	tr := tar.NewReader(f)
	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println(err)
			return err
		}
		path := filepath.Join(destDir, header.Name)
		if header.Typeflag == tar.TypeDir {
			os.MkdirAll(path, os.ModePerm)
		} else {
			f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, header.FileInfo().Mode())
			if err != nil {
				fmt.Println(err)
				return err
			}
			defer f.Close()
			_, err = io.Copy(f, tr)
			if err != nil {
				fmt.Println(err)
				return err
			}
		}
	}
	fmt.Println("解压tar完成")
	return nil
}
