package webui

import (
	"0E7/utils/client"
	"0E7/utils/config"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"io"
	"os"
	"path/filepath"
	"strings"
)

func exploit(c *gin.Context) {
	var err error
	exploit_uuid := c.PostForm("exploit_uuid")
	environment := c.PostForm("environment")
	command := c.PostForm("command")
	argv := c.PostForm("argv")
	platform := c.PostForm("platform")
	arch := c.PostForm("arch")
	times := c.PostForm("times")
	filter := c.PostForm("filter")
	file, err := c.FormFile("file")

	if exploit_uuid == "" {
		exploit_uuid = uuid.New().String()
	}

	if err == nil {
		fileName := file.Filename
		if times == "" {
			times = "-2"
		}

		var count int
		err := config.Db.QueryRow("SELECT COUNT(*) FROM `0e7_exploit` WHERE uuid=?", exploit_uuid).Scan(&count)
		if err != nil {
			fmt.Println("Failed to query database:", err)
		}
		if count == 0 {
			_, err = config.Db.Exec("INSERT INTO `0e7_exploit` (uuid,filename,environment,command,argv,platform,arch,filter,times) VALUES (?,?,?,?,?,?,?,?,?)", exploit_uuid, fileName, environment, command, argv, platform, arch, filter, times)
		} else {
			_, err = config.Db.Exec("UPDATE `0e7_exploit` SET environment=?,command=?,argv=?,times=?,filter=?,platform=?,arch=? WHERE uuid=?", environment, command, argv, times, platform, arch, filter, exploit_uuid)
		}
		if err != nil {
			c.JSON(400, gin.H{
				"message": "Fail",
				"err":     err,
			})
			fmt.Println(err)
			c.Abort()
			return
		}

		//fileName := exploit_uuid + filepath.Ext(file.Filename)
		savePath := fmt.Sprintf("exploit/%s/", exploit_uuid)
		if err = os.MkdirAll(savePath, os.ModePerm); err != nil {

			c.JSON(500, gin.H{
				"message": fmt.Sprintf("Error creating directory: %s", err.Error()),
			})
			return
		}
		saveFilePath := filepath.Join(savePath, fileName)
		if err := c.SaveUploadedFile(file, saveFilePath); err != nil {
			c.JSON(500, gin.H{
				"message": fmt.Sprintf("Error saving file: %s", err.Error()),
			})
			return
		}
		if strings.HasSuffix(fileName, ".zip") {
			if err = client.Unzip(fileName, exploit_uuid); err != nil {
				c.JSON(500, gin.H{
					"message": fmt.Sprintf("Unzip file Error: %s", err.Error()),
				})
				return
			}
		} else if strings.HasSuffix(fileName, ".tar") {
			if err = client.Untar(fileName, exploit_uuid); err != nil {
				c.JSON(500, gin.H{
					"message": fmt.Sprintf("Untar file Error: %s", err.Error()),
				})
				return
			}
		}
		c.JSON(200, gin.H{
			"message":      fmt.Sprintf("File %s uploaded successfully", fileName),
			"exploit_uuid": exploit_uuid,
		})
	}
}

func exploit_rename(c *gin.Context) {
	var err error
	old := c.PostForm("old")
	new := c.PostForm("new")

	if new == "" {
		new = uuid.New().String()
	}
	_, err = config.Db.Exec("UPDATE `0e7_exploit` SET uuid=? WHERE uuid=?", new, old)
	if err != nil {
		c.JSON(400, gin.H{
			"message": "uuid parameter error",
			"err":     err,
		})
		fmt.Println(err)
		c.Abort()
		return
	}

	err = os.Rename("exploit/"+old, "exploit/"+new)
	if err != nil {
		err = CopyDir("exploit/"+old, "exploit/"+new)
		if err != nil {
			c.JSON(400, gin.H{
				"message": "fail rename folder",
				"err":     err,
			})
		} else {
			c.JSON(202, gin.H{
				"message": "The folder is being occupied, operation copy instead, please manually delete the original folder",
			})
		}
		return
	}
	c.JSON(200, gin.H{
		"message": fmt.Sprintf("File rename to %s successfully", new),
	})
}

func CopyDir(srcPath string, destPath string) error {
	if srcInfo, err := os.Stat(srcPath); err != nil {
		fmt.Println(err.Error())
		return err
	} else {
		if !srcInfo.IsDir() {
			e := errors.New("srcPath不是一个正确的目录！")
			fmt.Println(e.Error())
			return e
		}
	}
	if destInfo, err := os.Stat(destPath); err != nil {
		if err = os.MkdirAll(destPath, os.ModePerm); err != nil {
			return err
			fmt.Println(err.Error())
		}
	} else {
		if !destInfo.IsDir() {
			e := errors.New("destInfo不是一个正确的目录！")
			fmt.Println(e.Error())
			return e
		}
	}
	err := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return err
		}
		if !f.IsDir() {
			path := strings.Replace(path, "\\", "/", -1)
			destNewPath := strings.Replace(path, srcPath, destPath, -1)
			fmt.Println("复制文件:" + path + " 到 " + destNewPath)
			copyFile(path, destNewPath)
		}
		return nil
	})
	if err != nil {
		fmt.Printf(err.Error())
	}
	return err
}

func copyFile(src, dest string) (w int64, err error) {
	srcFile, err := os.Open(src)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer srcFile.Close()
	destSplitPathDirs := strings.Split(dest, "/")
	destSplitPath := ""
	for index, dir := range destSplitPathDirs {
		if index < len(destSplitPathDirs)-1 {
			destSplitPath = destSplitPath + dir + "/"
			b, _ := pathExists(destSplitPath)
			if b == false {
				fmt.Println("创建目录:" + destSplitPath)
				err := os.Mkdir(destSplitPath, os.ModePerm)
				if err != nil {
					fmt.Println(err)
				}
			}
		}
	}
	dstFile, err := os.Create(dest)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	defer dstFile.Close()

	return io.Copy(dstFile, srcFile)
}

func pathExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}
